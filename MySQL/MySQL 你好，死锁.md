# MySQL 你好，死锁

![](./images/deadlock-1.jpg)

## 前言

在日常的生活中，相信大家曾或多或少有这么一种体验："每到下班高峰期的时候，原本宽坦的交通干道，一时间变得水泄不通，司机和乘客都烦躁不安，喇叭声响成一片，当车卡在十字路口中间，会很尴尬的发现，此时无论想走哪都…..."。对于这样的体验，大家都是十分的害怕接触和体验，交通部门也无时无刻为解决交通拥堵问题而努力。

其实上面生活案例中拥堵就类似于——`高并发`场景；

而所有方向的车堵在十字路口中间就类似于——`数据库死锁`场景。

本章主要围绕`InnoDB存储引擎`死锁相关的一些概念、产生死锁的原因、死锁场景以及死锁的处理策略。



## 相关概念

为了更好的认识`死锁`，我们先来了解`MySQL`中与死锁相关的一些基本概念。

### 并发控制

并发控制（Concurrency control）指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。

#### 读写锁

为了保证数据库的并发控制，因此`MySQL`设置了两种锁：

- 共享锁（Shared Lock）：也叫读锁（Read Lock），允许多个连接可以同一时刻并发的读取同一资源，互不干扰
- 排他锁（Exclusive Lock）：也叫写锁（Write Lock），会阻塞其他写锁或者读书的请求，保证同一时刻只有一个连接可以操作数据，包括读

#### 锁策略

所谓`锁策略`就是在锁的开销和数据的安全性之间寻求平衡，这种平衡会影响到性能。目前`InnoDB存储引擎`有以下两种锁策略：

 - Table Lock（表锁）策略：最基本的锁策略，开销最小，加锁快，不会出现死锁，但发生锁冲突概率高，粒度大，并发低
 - Row Lock（行锁）策略：粒度最小，发生锁冲突态度低，并发也高，但是开销大，加锁慢，会出现死锁

### 事务

所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。一个`事务`是需要通过严格ACID测试的：

- 原子性(ATOMICITY)：一个事务的整个操作，要么全部提交成功，要么全部失败回滚，不能执行其中的某一部分
- 一致性(CONSISTENCY)：数据库总是从一个一致性的状态转换到另外一个一致性的状态
- 隔离性(ISOLATION)：一个事物所作的修改在提交前，其他事务是看不到的
- 持久性(DURABILITY)：一旦事务提交，则其所做的修改就会永久保存到数据库中

#### 隔离级别

SQL标准制定了四种隔离级别，规定事务的修改对其它事务是否可见

- READ UNCOMMITED 未提交读：未提交也可见，又称**脏读**

- READ COMMITED 提交读：只有提交才可见，大多数DBMS默认隔离级别都是这个，MySQL不是，也称**不可重复读**

- REPEATABLE READ 可重复读，多次重复读取结果一致，MySQL默认这个级别，解决**脏读**问题，但存在**幻读**问题（某个事务读取记录时，另一事务插入了新纪录，原事务再读取记录时产生幻行），InnoDB/XtraDB通过多版本并发控制MVCC解决幻读问题

- SERIALIZABLE 可串行化，最高隔离级别，强制事务串行执行，完全没有并发性能







## 死锁的定义











## 死锁的危害



## 死锁产生的原因





## 死锁的发生场景

### 场景一



### 场景二



## 死锁的处理策略

### 预防死锁



### 避免死锁



### 死锁的检测和解除



## 参考文章

《高性能的MySQL 第三版》



https://www.kancloud.cn/hanghanghang/os/239542#_38







## 



https://my.oschina.net/u/1399755/blog/1788881



[https://benjaminwhx.com/2018/02/28/%E7%94%B1%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%A5%E7%9A%84MySQL%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/](https://benjaminwhx.com/2018/02/28/由一次线上问题带来的MySQL死锁问题分析/)